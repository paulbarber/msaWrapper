print.auc=TRUE, print.thres=TRUE)
print(cor.test(ElasNet_model$best_Predicted_risk, CancerDx, method = "kendall"))
traindata <- data.frame(ElasNet_model$best_Predicted_risk, CancerDx)
names(traindata) <- c("RiskScore", "Class")
traindata$Class <- as.factor(CancerDx)
traindata$RiskScore <- ElasNet_model$best_Predicted_risk
ggp <- ggplot(traindata, aes(x = Class, y = RiskScore, group = Class)) +
geom_boxplot(outlier.colour = NA) +
geom_jitter(width = 0.2, col = rgb(0.1, 0.2, 0.8, 0.3)) +
theme_classic()
print(ggp)
roc(traindata$Class, traindata$RiskScore,
smoothed = TRUE, quiet = TRUE,
# arguments for ci
ci=FALSE, ci.alpha=0.9, stratified=FALSE,
# arguments for plot
plot=TRUE, auc.polygon=TRUE, max.auc.polygon=TRUE,
grid=TRUE,
print.auc=TRUE, print.thres=TRUE)
best_Predicted_response <- predict(ElasNet_model$glmnet_model, as.matrix(Tex_RADx_test_2),type ="link",s = ElasNet_model$optimal_lambda)
data <- data.frame(best_Predicted_response, test_outcomes)
names(data) <- c("RiskScore", "Class")
print(cor.test(data$RiskScore, data$Class, method = "kendall"))
ggp <- ggplot(data, aes(x = Class, y = RiskScore, group = data$Class)) +
geom_boxplot(outlier.colour = NA) +
geom_jitter(width = 0.2, col = rgb(0.1, 0.2, 0.8, 0.3)) +
theme_classic()
print(ggp)
roc(data$Class, data$RiskScore,
smoothed = TRUE, quiet = TRUE,
# arguments for ci
ci=FALSE, ci.alpha=0.9, stratified=FALSE,
# arguments for plot
plot=TRUE, auc.polygon=TRUE, max.auc.polygon=TRUE,
grid=TRUE,
print.auc=TRUE, print.thres=TRUE)
knitr::opts_chunk$set(echo = TRUE)
library(ggfortify)
library(msaWrapper)
library(pROC)
library(dplyr)
library(readxl)
dataset <- read.csv("all_feats_predictive_models_resize_15092022.csv")
colname <- colnames(dataset)
firstrownames <- dataset[1,] #Getting first row
newcolname <- c()
newcolname <- append(newcolname,'ID')
colcnt <- 2
modelnamecol <- 2
while (colcnt < length(colname)){
#print (colcnt)
extracted_col_count <- strex::str_first_number(dataset[1, c(colcnt)])
#print (extracted_col_count)
if (extracted_col_count ==0){
modelnamecol <-colcnt
}
newname <- paste(colname[modelnamecol],firstrownames[colcnt],sep = "_")
newcolname <- append(newcolname,newname)
colcnt <- colcnt+1
}
colnames(dataset) <- newcolname
colnames(dataset)[length(dataset)] = "Resized"
dataset = dataset[-1,]
row.names(dataset) <- NULL
i <- c(2:length(dataset))
dataset[ , i] <- apply(dataset[ , i], 2, function(x) as.numeric(as.character(x)))
load("Testset.rda")
#testdataRDS <- readRDS("Testset.Rds")
#flow_train <- flow[!(flow$ID %in% testSet),]
DL_RADx_train <- dataset[!(dataset$ID %in% testSet),]
#flow_test <- flow[flow$ID %in% testSet,]
DL_RADx_test <- dataset[dataset$ID %in% testSet,]
#sapply(dataset, class)
save(DL_RADx_train, file = "DL_RDx_data.Rdata")
outcomes <- read.csv("../from_Thida and Sheena Lim/KCL_LungEDx_Outcomes Sept2022.csv")
data_name <- "DL_RADx"
# more patients with outcomes than in the data
# merge to get just those with data
merged_data <- merge(DL_RADx_train, outcomes, by = "ID", all.x = T)
#CancerDx <- dataset[,length(dataset)]
#colnames(dataset)[length(dataset)] = "CancerDx"
# get rid of any without outcome
# report which ones first
#merged_data[is.na(merged_data$CancerDx), "ID"]
merged_data <- merged_data[!is.na(merged_data$CancerDx),]
# get the merged outcomes
CancerDx <- merged_data$CancerDx
# get just the data we want for training
merged_data_2 <- subset(merged_data, select = -c(Date.of.Compilation,
Date.of.Consent,
Smoker.Hx,
DoD,
CancerDxClass,
CancerDx,
OS_time..days.,
OS_event))
# Create msa wrapper object to use for analysis}
DL_RADx_msa <- msaWrapperCreate(data = merged_data_2,
outcome = CancerDx,
rowsLabelled = T)
print(DL_RADx_msa)
#plotOutcome(DL_RADx_msa)
#plotDataCorrelations(DL_RADx_msa, method = "kendall")
DL_RADx_msa <- generateOutcomeCorrelations(DL_RADx_msa)
plotOutcomeCorrelations(DL_RADx_msa)
test_outcomes <- outcomes$CancerDx[outcomes$ID %in% testSet]
outcomes$ID[outcomes$ID %in% testSet]
print("testSet")
testSet
print("DL_RADX_test")
DL_RADx_test$ID
ElasNet_model <-buildElasticNet(DL_RADx_msa,iterations = 5000,alpha=1)
#saveRDS(ElasNet_model, file = paste0(data_name, "_ElsticNet_Lasso_model.Rds"))
DL_RADx_msa$type
print(cor.test(ElasNet_model$best_Predicted_risk, CancerDx, method = "kendall"))
traindata <- data.frame(ElasNet_model$best_Predicted_risk, CancerDx)
names(traindata) <- c("RiskScore", "Class")
traindata$Class <- as.factor(CancerDx)
traindata$RiskScore <- ElasNet_model$best_Predicted_risk
ggp <- ggplot(traindata, aes(x = Class, y = RiskScore, group = Class)) +
geom_boxplot(outlier.colour = NA) +
geom_jitter(width = 0.2, col = rgb(0.1, 0.2, 0.8, 0.3)) +
theme_classic()
print(ggp)
roc(traindata$Class, traindata$RiskScore,
smoothed = TRUE, quiet = TRUE,
# arguments for ci
ci=FALSE, ci.alpha=0.9, stratified=FALSE,
# arguments for plot
plot=TRUE, auc.polygon=TRUE, max.auc.polygon=TRUE,
grid=TRUE,
print.auc=TRUE, print.thres=TRUE)
plotElasticNetCoefs(ElasNet_model, xvar = "dev")
plotElasticNetCoefs(ElasNet_model, xvar = "norm")
plotElasticNetCoefs(ElasNet_model, xvar = "lambda")
plotElasticNetPerformance(ElasNet_model)
i=1
for (var in ElasNet_model$optimal_covars){
cat(var, ' : ', ElasNet_model$optimal_coefs[i], "\n")
i=i+1
}
i=1
for (var in ElasNet_model$strict_covars){
cat(var, ' : ', ElasNet_model$strict_coefs[i], "\n")
i=i+1
}
DL_RADx_test_2 <- subset(DL_RADx_test, select = -c(ID))
best_Predicted_response <- predict(ElasNet_model$glmnet_model, as.matrix(DL_RADx_test_2),type ="link",s = ElasNet_model$optimal_lambda)
best_Predicted_response <- as.numeric(best_Predicted_response)
data <- data.frame(best_Predicted_response, test_outcomes)
names(data) <- c("RiskScore", "Class")
print(cor.test(data$RiskScore, data$Class, method = "kendall"))
ggp <- ggplot(data, aes(x = Class, y = RiskScore, group = data$Class)) +
geom_boxplot(outlier.colour = NA) +
geom_jitter(width = 0.2, col = rgb(0.1, 0.2, 0.8, 0.3)) +
theme_classic()
print(ggp)
roc(data$Class, data$RiskScore,
smoothed = TRUE, quiet = TRUE,
# arguments for ci
ci=FALSE, ci.alpha=0.9, stratified=FALSE,
# arguments for plot
plot=TRUE, auc.polygon=TRUE, max.auc.polygon=TRUE,
grid=TRUE,
print.auc=TRUE, print.thres=TRUE)
best_Predicted_response <- predict(ElasNet_model$glmnet_model, as.matrix(DL_RADx_test_2),type ="link",s = ElasNet_model$strict_lambda)
data <- data.frame(best_Predicted_response, test_outcomes)
names(data) <- c("RiskScore", "Class")
print(cor.test(data$RiskScore, data$Class, method = "kendall"))
ggp <- ggplot(data, aes(x = Class, y = RiskScore, group = data$Class)) +
geom_boxplot(outlier.colour = NA) +
geom_jitter(width = 0.2, col = rgb(0.1, 0.2, 0.8, 0.3)) +
theme_classic()
print(ggp)
roc(data$Class, data$RiskScore,
smoothed = TRUE, quiet = TRUE,
# arguments for ci
ci=FALSE, ci.alpha=0.9, stratified=FALSE,
# arguments for plot
plot=TRUE, auc.polygon=TRUE, max.auc.polygon=TRUE,
grid=TRUE,
print.auc=TRUE, print.thres=TRUE)
knitr::opts_chunk$set(echo = TRUE)
library(ggfortify)
library(msaWrapper)
library(pROC)
#install.packages("readxl")
#library("readxl")
dataset_Xiaolan_1 <- read.csv("EDX human plasma exosome protein analysis-08112022.csv")
dataset_Xiaolan_2 <- read.csv("EDX human plasma exosome protein analysis-25112022.csv")
dataset_Xiaolan <- rbind(dataset_Xiaolan_1, dataset_Xiaolan_2)
dataset_Jose <- read.csv("../from_Jose exosome_protein_data/EDX data Jose V.csv")
dataset_Jose$EDX.Number <- paste('EDX',formatC(dataset_Jose$EDX.Number, width=3, flag="0"),sep = "")
dataset_Xiaolan$batch <- 0
dataset_Jose$batch <- 1
Merged_Dataset <- rbind(dataset_Xiaolan, dataset_Jose)
#Merged_Dataset <- dataset_Jose
colnames(Merged_Dataset)[1] <- "ID"
Merged_Dataset$ID
n <- "EDX064"
d <- Merged_Dataset[Merged_Dataset$ID == n, ]
a <- as.numeric(as.vector(t(d[1,])))
b <- as.numeric(as.vector(t(d[2,])))
c <- (a + b) / 2
names(c) <- names(Merged_Dataset)
c$ID <- n
# remove the duplicates
Merged_Dataset <- Merged_Dataset[!(Merged_Dataset$ID == n), ]
# Add new row
Merged_Dataset <- rbind(Merged_Dataset, c)
d <- Merged_Dataset[,-1]
d <- d[,-length(d)]
e <- Merged_Dataset
# impute missing vals
NA2mean <- function(x) replace(x, is.na(x), mean(x, na.rm = TRUE))
d[] <- lapply(d, NA2mean)
e$batch <- as.factor(e$batch)
data.pca <- prcomp(d, center = T, scale. = T)
autoplot(data.pca, data = e, colour = 'batch') +
ggtitle("PCA: Combining Dotblot exosome Protein ")
load("Testset.rda")
#testdataRDS <- readRDS("Testset.Rds")
d <- Merged_Dataset[,-1]
e <- Merged_Dataset
# impute missing vals
NA2mean <- function(x) replace(x, is.na(x), mean(x, na.rm = TRUE))
d[] <- lapply(d, NA2mean)
e$test <- as.factor(ifelse(Merged_Dataset$ID %in% testSet,1, 0))
data.pca <- prcomp(d, center = T, scale. = T)
autoplot(data.pca, data = e, colour = 'test') +
ggtitle("PCA: Dotblot exosome Protein")
i <- c(2:length(Merged_Dataset))
Merged_Dataset[ , i] <- apply(Merged_Dataset[ , i], 2, function(x) as.numeric(as.character(x)))
#flow_train <- flow[!(flow$ID %in% testSet),]
Dot_Ex_train <- Merged_Dataset[!(Merged_Dataset$ID %in% testSet),]
#flow_test <- flow[flow$ID %in% testSet,]
Dot_Ex_test <- Merged_Dataset[Merged_Dataset$ID %in% testSet,]
#sapply(dataset, class)
Dotblotdata_jose <- Merged_Dataset
save(Dot_Ex_train, file = "Dotblot_Ex.Rdata")
save(Dotblotdata_jose, file = "Full_Dotblot_Ex.Rdata")
outcomes <- read.csv("../from_Thida and Sheena Lim/KCL_LungEDx_Outcomes Sept2022.csv")
data_name <- "Dot_Ex_Pro"
# more patients with outcomes than in the data
# merge to get just those with data
Dot_Ex_train_O <- merge(Dot_Ex_train, outcomes, by = "ID", all.x = T)
#CancerDx <- dataset[,length(dataset)]
#colnames(dataset)[length(dataset)] = "CancerDx"
# get rid of any without outcome
# report which ones first
#merged_data[is.na(merged_data$CancerDx), "ID"]
Dot_Ex_train_O <- Dot_Ex_train_O[!is.na(Dot_Ex_train_O$CancerDx),]
# get the merged outcomes
CancerDx <- Dot_Ex_train_O$CancerDx
# get just the data we want for training
#merged_data <- subset(merged_data, select = -c(CancerDx))
Dot_Ex_train_O <- subset(Dot_Ex_train_O, select = -c(Date.of.Compilation,
Date.of.Consent,
Smoker.Hx,
DoD,
CancerDxClass,
CancerDx,
OS_time..days.,
OS_event))
# Create msa wrapper object to use for analysis}
Dot_Ex_Pro_msa <- msaWrapperCreate(data = Dot_Ex_train_O,
outcome = CancerDx,
rowsLabelled = T)
print(Dot_Ex_Pro_msa)
plotOutcome(Dot_Ex_Pro_msa)
plotDataCorrelations(Dot_Ex_Pro_msa, method = "kendall")
Dot_Ex_Pro_msa <- generateOutcomeCorrelations(Dot_Ex_Pro_msa)
plotOutcomeCorrelations(Dot_Ex_Pro_msa)
test_outcomes <- outcomes$CancerDx[outcomes$ID %in% Dot_Ex_test$ID]
outcomes$ID[outcomes$ID %in% Dot_Ex_test$ID]
print("testSet")
testSet
print("Dot_Ex__test")
Dot_Ex_test$ID
test_data <- Dot_Ex_test
riskSignatureDataframe <- read.table("Dot_Ex_Pro/Reg_SETCV_MAP_L2/RiskScore_formula.txt", sep = '*', col.names = c("Weight", "Covariate"),    stringsAsFactors = F, skip = 2, fill = T)
testresults <-calculateRiskScore(riskSignatureDataframe, test_data)
data <- data.frame(testresults, test_outcomes)
names(data) <- c("RiskScore", "Class")
print(cor.test(data$RiskScore, data$Class, method = "kendall"))
data$Class <- as.factor(data$Class)
ggp <- ggplot(data, aes(x = Class, y = RiskScore, group = Class)) +
geom_boxplot(outlier.colour = NA) +
geom_jitter(width = 0.2, col = rgb(0.1, 0.2, 0.8, 0.3)) +
theme_classic()
print(ggp)
roc(data$Class, data$RiskScore,
smoothed = TRUE, quiet = TRUE,
# arguments for ci
ci=FALSE, ci.alpha=0.9, stratified=FALSE,
# arguments for plot
plot=TRUE, auc.polygon=TRUE, max.auc.polygon=TRUE,
grid=TRUE,
print.auc=TRUE, print.thres=TRUE)
ElasNet_model <-buildElasticNet(Dot_Ex_Pro_msa,iterations = 5,alpha=1)
saveRDS(ElasNet_model, file = paste0(data_name, "_ElsticNet_Lasso_model.Rds"))
print(cor.test(ElasNet_model$strict_Predicted_risk, CancerDx, method = "kendall"))
traindata <- data.frame(ElasNet_model$strict_Predicted_risk, CancerDx)
names(traindata) <- c("RiskScore", "Class")
traindata$Class <- as.factor(CancerDx)
traindata$RiskScore <- ElasNet_model$strict_Predicted_risk
ggp <- ggplot(traindata, aes(x = Class, y = RiskScore, group = Class)) +
geom_boxplot(outlier.colour = NA) +
geom_jitter(width = 0.2, col = rgb(0.1, 0.2, 0.8, 0.3)) +
theme_classic()
print(ggp)
ElasNet_model <-buildElasticNet(Dot_Ex_Pro_msa,iterations = 5000,alpha=1)
saveRDS(ElasNet_model, file = paste0(data_name, "_ElsticNet_Lasso_model.Rds"))
print(cor.test(ElasNet_model$strict_Predicted_risk, CancerDx, method = "kendall"))
traindata <- data.frame(ElasNet_model$strict_Predicted_risk, CancerDx)
names(traindata) <- c("RiskScore", "Class")
traindata$Class <- as.factor(CancerDx)
traindata$RiskScore <- ElasNet_model$strict_Predicted_risk
ggp <- ggplot(traindata, aes(x = Class, y = RiskScore, group = Class)) +
geom_boxplot(outlier.colour = NA) +
geom_jitter(width = 0.2, col = rgb(0.1, 0.2, 0.8, 0.3)) +
theme_classic()
print(ggp)
plotElasticNetCoefs(ElasNet_model, xvar = "dev")
plotElasticNetCoefs(ElasNet_model, xvar = "norm")
plotElasticNetCoefs(ElasNet_model, xvar = "lambda")
plotElasticNetPerformance(ElasNet_model)
Dot_Ex_test_2 <- subset(Dot_Ex_test, select = -c(ID))
best_Predicted_response <- predict(ElasNet_model$glmnet_model, as.matrix(Dot_Ex_test_2),type ="link",s = ElasNet_model$strict_lambda)
best_Predicted_response <- as.numeric(best_Predicted_response)
best_Predicted_response
i=1
for (var in ElasNet_model$optimal_covars){
cat(var, ' : ', ElasNet_model$optimal_coefs[i], "\n")
i=i+1
}
i=1
for (var in ElasNet_model$strict_covars){
cat(var, ' : ', ElasNet_model$strict_coefs[i], "\n")
i=i+1
}
data <- data.frame(best_Predicted_response, test_outcomes)
names(data) <- c("RiskScore", "Class")
print(cor.test(data$RiskScore, data$Class, method = "kendall"))
ggp <- ggplot(data, aes(x = Class, y = RiskScore, group = data$Class)) +
geom_boxplot(outlier.colour = NA) +
geom_jitter(width = 0.2, col = rgb(0.1, 0.2, 0.8, 0.3)) +
theme_classic()
print(ggp)
roc(data$Class, data$RiskScore,
smoothed = TRUE, quiet = TRUE,
# arguments for ci
ci=FALSE, ci.alpha=0.9, stratified=FALSE,
# arguments for plot
plot=TRUE, auc.polygon=TRUE, max.auc.polygon=TRUE,
grid=TRUE,
print.auc=TRUE, print.thres=TRUE)
best_Predicted_response <- predict(ElasNet_model$glmnet_model, as.matrix(Dot_Ex_test_2),type ="link",s = ElasNet_model$optimal_lambda)
data <- data.frame(best_Predicted_response, test_outcomes)
names(data) <- c("RiskScore", "Class")
print(cor.test(data$RiskScore, data$Class, method = "kendall"))
ggp <- ggplot(data, aes(x = Class, y = RiskScore, group = data$Class)) +
geom_boxplot(outlier.colour = NA) +
geom_jitter(width = 0.2, col = rgb(0.1, 0.2, 0.8, 0.3)) +
theme_classic()
print(ggp)
roc(data$Class, data$RiskScore,
smoothed = TRUE, quiet = TRUE,
# arguments for ci
ci=FALSE, ci.alpha=0.9, stratified=FALSE,
# arguments for plot
plot=TRUE, auc.polygon=TRUE, max.auc.polygon=TRUE,
grid=TRUE,
print.auc=TRUE, print.thres=TRUE)
print(cor.test(ElasNet_model$strict_Predicted_risk, CancerDx, method = "kendall"))
traindata <- data.frame(ElasNet_model$strict_Predicted_risk, CancerDx)
names(traindata) <- c("RiskScore", "Class")
traindata$Class <- as.factor(CancerDx)
traindata$RiskScore <- ElasNet_model$strict_Predicted_risk
ggp <- ggplot(traindata, aes(x = Class, y = RiskScore, group = Class)) +
geom_boxplot(outlier.colour = NA) +
geom_jitter(width = 0.2, col = rgb(0.1, 0.2, 0.8, 0.3)) +
theme_classic()
print(ggp)
roc(traindata$Class, traindata$RiskScore,
smoothed = TRUE, quiet = TRUE,
# arguments for ci
ci=FALSE, ci.alpha=0.9, stratified=FALSE,
# arguments for plot
plot=TRUE, auc.polygon=TRUE, max.auc.polygon=TRUE,
grid=TRUE,
print.auc=TRUE, print.thres=TRUE)
Dotblotdata_jose_s<- subset(Dotblotdata_jose, select = c(S100A9, P4HA1, TIGIT, BAG6, HER2, HMGB1, CD73, PD1, CD226, ICOSL, CD96, B2M, CD63, MET, batch))
cormat <- cor(Balji_dataset_selected, method = method, use = "pairwise.complete.obs")
melted_cormat <- reshape2::melt(cormat)
Plotcor(melted_cormat)
cormat <- cor(Dotblotdata_jose_s, method = method, use = "pairwise.complete.obs")
melted_cormat <- reshape2::melt(cormat)
Plotcor(melted_cormat)
setwd("D:/Lung EDx/Combined_Dataset")
knitr::opts_chunk$set(echo = TRUE)
library(ggfortify)
library(msaWrapper)
library(pROC)
load('../Deep learning radiomics/DL_RDx_data.Rdata')
load('../Radiomics_Balaji/Tex_Rad_data.Rdata')
load('../Flow Cytometry Analysis/flow_Normalised_data.Rdata')
load('../Dotblot exosome protein data/Full_Dotblot_Ex.Rdata')
Dotblotdata <- Dotblotdata_jose
FullIDlist <- c(Tex_RADx$ID,flow_norm$ID,DL_RADx$ID,Dotblotdata$ID)
FullIDlist <-FullIDlist[!duplicated(FullIDlist, fromLast = TRUE)]
length(FullIDlist)
FinalDataset_selective <- merge(Tex_RADx,flow_norm,by="ID", all=TRUE)
selected_DL_RADx <- subset(DL_RADx, select = c(ID,GANAE_nz_32_lmbda_0.5_feats_resize_z_10, GANAE_nz_512_lmbda_0.5_feats_resize_z_72, GANAE_nz_512_lmbda_0.5_feats_resize_z_112, GANAE_nz_512_lmbda_0.5_feats_resize_z_428, GANAE_nz_512_lmbda_0.5_feats_resize_z_32 , GANAE_nz_512_lmbda_0.5_feats_resize_z_85 , GANAE_nz_512_lmbda_0.5_feats_resize_z_108 , GANAE_nz_512_lmbda_0.5_feats_resize_z_277, VSSAE_nzmult_1_scalebeta_beta_0.000004_feats_resize_z_4, VSSAE_nzmult_1_scalebeta_beta_0.000004_feats_resize_z_50, VSSAE_nzmult_1_scalebeta_beta_0.000004_feats_resize_z_63, VSSAE_nzmult_2_scalebeta_beta_0.000003_feats_resize_z_206, VSSAE_nzmult_2_scalebeta_beta_0.000003_feats_resize_z_227,
VSSAE_nzmult_1_scalebeta_beta_0.000004_feats_resize_z_22, VSSAE_nzmult_1_scalebeta_beta_0.000004_feats_resize_z_28,
VSSAE_nzmult_1_scalebeta_beta_0.000004_feats_resize_z_36, VSSAE_nzmult_1_scalebeta_beta_0.000004_feats_resize_z_42 , VSSAE_nzmult_1_scalebeta_beta_0.000004_feats_resize_z_47 , VSSAE_nzmult_1_scalebeta_beta_0.000004_feats_resize_z_49  , VSSAE_nzmult_1_scalebeta_beta_0.000004_feats_resize_z_95 , VSSAE_nzmult_1_scalebeta_beta_0.000004_feats_resize_z_119 , VSSAE_nzmult_1_scalebeta_beta_0.000004_feats_resize_z_4, VSSAE_nzmult_1_scalebeta_beta_0.000004_feats_resize_z_50,
VSSAE_nzmult_1_scalebeta_beta_0.000004_feats_resize_z_59, VSSAE_nzmult_1_scalebeta_beta_0.000004_feats_resize_z_63, VSSAE_nzmult_1_scalebeta_beta_0.000004_feats_resize_z_109))
FinalDataset_selective <-merge(FinalDataset_selective,selected_DL_RADx,by="ID", all=TRUE)
MultiModal_selective <-merge(FinalDataset_selective,Dotblotdata_jose,by="ID", all=TRUE)
knitr::opts_chunk$set(echo = TRUE)
library(ggfortify)
library(msaWrapper)
library(pROC)
load('../Deep learning radiomics/DL_RDx_data.Rdata')
load('../Radiomics_Balaji/Tex_Rad_data.Rdata')
load('../Flow Cytometry Analysis/flow_Normalised_data.Rdata')
load('../Dotblot exosome protein data/Full_Dotblot_Ex.Rdata')
Dotblotdata <- Dotblotdata_jose
FullIDlist <- c(Tex_RADx$ID,flow_norm$ID,DL_RADx$ID,Dotblotdata$ID)
FullIDlist <-FullIDlist[!duplicated(FullIDlist, fromLast = TRUE)]
length(FullIDlist)
FinalDataset_selective <- merge(Tex_RADx,flow_norm,by="ID", all=TRUE)
selected_DL_RADx <- subset(DL_RADx, select = c(ID,GANAE_nz_32_lmbda_0.5_feats_resize_z_10, GANAE_nz_512_lmbda_0.5_feats_resize_z_72, GANAE_nz_512_lmbda_0.5_feats_resize_z_112, GANAE_nz_512_lmbda_0.5_feats_resize_z_428, GANAE_nz_512_lmbda_0.5_feats_resize_z_32 , GANAE_nz_512_lmbda_0.5_feats_resize_z_85 , GANAE_nz_512_lmbda_0.5_feats_resize_z_108 , GANAE_nz_512_lmbda_0.5_feats_resize_z_277, VSSAE_nzmult_1_scalebeta_beta_0.000004_feats_resize_z_4, VSSAE_nzmult_1_scalebeta_beta_0.000004_feats_resize_z_50, VSSAE_nzmult_1_scalebeta_beta_0.000004_feats_resize_z_63, VSSAE_nzmult_2_scalebeta_beta_0.000003_feats_resize_z_206, VSSAE_nzmult_2_scalebeta_beta_0.000003_feats_resize_z_227,
VSSAE_nzmult_1_scalebeta_beta_0.000004_feats_resize_z_22, VSSAE_nzmult_1_scalebeta_beta_0.000004_feats_resize_z_28,
VSSAE_nzmult_1_scalebeta_beta_0.000004_feats_resize_z_36, VSSAE_nzmult_1_scalebeta_beta_0.000004_feats_resize_z_42 , VSSAE_nzmult_1_scalebeta_beta_0.000004_feats_resize_z_47 , VSSAE_nzmult_1_scalebeta_beta_0.000004_feats_resize_z_49  , VSSAE_nzmult_1_scalebeta_beta_0.000004_feats_resize_z_95 , VSSAE_nzmult_1_scalebeta_beta_0.000004_feats_resize_z_119 , VSSAE_nzmult_1_scalebeta_beta_0.000004_feats_resize_z_4, VSSAE_nzmult_1_scalebeta_beta_0.000004_feats_resize_z_50,
VSSAE_nzmult_1_scalebeta_beta_0.000004_feats_resize_z_59, VSSAE_nzmult_1_scalebeta_beta_0.000004_feats_resize_z_63, VSSAE_nzmult_1_scalebeta_beta_0.000004_feats_resize_z_109))
FinalDataset_selective <-merge(FinalDataset_selective,selected_DL_RADx,by="ID", all=TRUE)
MultiModal_selective <-merge(FinalDataset_selective,Dotblotdata_jose,by="ID", all=TRUE)
MultiModal_selective$texrad_missing <- 0
MultiModal_selective$flownorm_missing <- 0
MultiModal_selective$dl_rad_missing <-0
MultiModal_selective$dotblot_missing <- 0
MultiModal_selective[is.na(MultiModal_selective$TX_sigma), ] $texrad_missing <- 1
MultiModal_selective[is.na(MultiModal_selective$CD4..T.regs), ]$flownorm_missing <- 1
MultiModal_selective[is.na(MultiModal_selective$VSSAE_nzmult_1_scalebeta_beta_0.000004_feats_resize_z_4), ]$dl_rad_missing <- 1
MultiModal_selective[is.na(MultiModal_selective$mean), ]$dotblot_missing <- 1
MultiModal_selective <- subset(MultiModal_selective, select = -c(Algorithm))
load("Testset.rda")
for(i in 1:ncol(MultiModal_selective)){
MultiModal_selective[is.na(MultiModal_selective[,i]), i] <- mean(MultiModal_selective[,i], na.rm = TRUE)
}
#flow_train <- flow[!(flow$ID %in% testSet),]
MultiModal_selective_train <- MultiModal_selective[!(MultiModal_selective$ID %in% testSet),]
#flow_test <- flow[flow$ID %in% testSet,]
MultiModal_selective_test <- MultiModal_selective[MultiModal_selective$ID %in% testSet,]
MultiModal_selective
save(MultiModal_selective, file = "MultiModal_selective.Rdata")
outcomes <- read.csv("../from_Thida and Sheena Lim/KCL_LungEDx_Outcomes Sept2022.csv")
data_name <- "Multi_Modal_S"
# more patients with outcomes than in the data
# merge to get just those with data
merged_data <- merge(MultiModal_selective_train, outcomes, by = "ID", all.x = T)
#CancerDx <- dataset[,length(dataset)]
#colnames(dataset)[length(dataset)] = "CancerDx"
# get rid of any without outcome
# report which ones first
#merged_data[is.na(merged_data$CancerDx), "ID"]
merged_data <- merged_data[!is.na(merged_data$CancerDx),]
# get the merged outcomes
CancerDx <- merged_data$CancerDx
# get just the data we want for training
merged_data_2 <- subset(merged_data, select = -c(Date.of.Compilation,
Date.of.Consent,
Smoker.Hx,
DoD,
CancerDxClass,
CancerDx,
OS_time..days.,
OS_event))
# Create msa wrapper object to use for analysis}
MultiModal_selective_train_msa <- msaWrapperCreate(data = merged_data_2,
outcome = CancerDx,
rowsLabelled = T)
print(MultiModal_selective_train_msa)
plotOutcome(MultiModal_selective_train_msa)
plotDataCorrelations(MultiModal_selective_train_msa, method = "kendall")
MultiModal_selective_train_msa <- generateOutcomeCorrelations(MultiModal_selective_train_msa)
plotOutcomeCorrelations(MultiModal_selective_train_msa)
saveRDS(MultiModal_selective_train_msa, file = paste0(data_name, "_msa.Rds"))
filename <- "Multi_Modal"
regression_folder <- "Reg_SETCV_MAP_L2_Adaptive"
sigFile <- paste0(filename, "/", regression_folder, "/RiskScore_formula.txt")
if(!file.exists(sigFile)) stop("No output produced by Saddle Point software. Is it installed with a valid license?")
riskSignatureDataframe <- read.table(sigFile, sep = '*', col.names = c("Weight", "Covariate"), stringsAsFactors = F, skip = 2, fill = T)
print(riskSignatureDataframe)
SPS_model <- structure(list("Multi_Modal", 5000, regression_folder, riskSignatureDataframe, Multi_Modal_msa$type),
.Names = c("runName", "iterations", "regressionFolder", "riskSignature", "dataType"),
class = "msaWrapperSPSignatureOclass")
library(msaWrapper)
# REMEMBER TO SET THE WORKING FOLDER - THAT'S WHERE THE RESULTS WILL GO
data_name <- "Multi_Modal_S"
msa <- readRDS(paste0(data_name, "_msa.Rds"))
SPS_model <- buildSPSignature(msa, data_name, iterations = 5000)
saveRDS(SPS_model, file = paste0(data_name, "_SPS_model.Rds"))
file.rename("SPS_Signature_logfile.txt", paste0(data_name, "_SPS_Signature_logfile.txt"))
setwd("D:/MSAWrapper/msaWrapper")
library(msaWrapper)
detach("package:msaWrapper", unload = TRUE)
library(msaWrapper)
library(msaWrapper)
library(msaWrapper)
library(msaWrapper)
