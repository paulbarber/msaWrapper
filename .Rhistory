active_covar_scores[[n_repeat]] <- NA
break
}
}
# choose optimal model
if(byOOB == TRUE){
# Choose max of OOB performance
max_i <- which.max(OOB_c_index)
}else{
# Choose max of validation performance
max_i <- which.max(valid_c_index)
}
optimal_p <- active_covars[max_i]
optimal_names <- active_covar_names[[max_i]]
#x <- data[, -c(p-1,p)]
x <- msa$data
optimal_x <- subset(x, select = optimal_names)
optimal_data <- cbind(optimal_x, outcome)
print(paste("Optimal p=", optimal_p))
# Do iterations to find a good rf with optimal p
best_perf = 0
best_rf = NULL
for (i in 1:iterations){
setTxtProgressBar(ProgressBar, i)
# train RF
rf <- randomForestSRC::rfsrc(formula,
data = optimal_data,
na.action = "na.impute",
importance = TRUE,
proximity = TRUE)
# OOB prediction
perf = randomForestSRC::get.cindex(rf$yvar[,1], rf$yvar[,2], -rf$predicted.oob)
if(perf > best_perf){
best_perf = perf
best_rf <- rf
}
}
performance <- data.frame(active_covars,
train_c_index, train_ci_sd,
OOB_c_index, OOB_ci_sd,
valid_c_index, valid_ci_sd)
# return this object
structure(list(iterations, byOOB,
performance,
active_covar_names,
active_covar_scores,
optimal_p, optimal_names,
best_perf,
best_rf),
.Names = c("iterations", "byOOB",
"performance",
"active_covar_names", "active_covar_scores",
"optimal_p", "Optimal_covars",
"best_c_index",
"trained_random_forest"),
class = "msaWrapperRandomSurvivalForest")
}
rf <- buildRandomForest2(msa, iterations = 4)
debugonce(buildRandomForest2)
rf <- buildRandomForest2(msa, iterations = 4)
View(rf)
rf$importance
msa_oc <- msa_oc
msa_oc <- msa
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
library(msaWrapper)
data("tte_data")
names(tte_data)
groups <- c(1, rep(2,2), rep(3,6), 1, rep(2,3), rep(4,26), 5, 6, 6, rep(7, 3),
rep(4,26), 6, 6, 5, rep(7, 3))
groupNames <- c("Drug", "Clinical", "Site", "immune", "FRET", "miR", "missing")
length(groups)
msa <- msaWrapperCreate(tte_data[,1:77], tte_data[,78:79],
group = groups, groupLabels = groupNames)
print(msa)
msa_tte <- msa
debugonce(buildRandomForest2)
rf_tte <- buildRandomForest2(msa_tte, iterations = 4)
View(rf)
class(rf$importance)
groups[,1]
#' buildRandomForest.msaWrapperTte
#'
#' Build a Random Forest Classifier for time to event outcome
#' @param msa The msaWrapper object to work with.
#' @param iterations The number of randomForest calls to make for the active covars.
#' @param byOOB Use out of bag performance measure, if false use 50:50 cross validation
#' @return An object containing the trained RF and it's performance.
#' @export
#'
#buildRandomForest.msaWrapperTte <- function(msa, iterations=200, byOOB = TRUE){
buildRandomForest2 <- function(msa, iterations=200, byOOB = TRUE){
#stopifnot(msa$type == "time to event data")
# data is a Data frame containing the y-outcome (2 cols at the end) and x-variables. No label column.
data <- cbind(msa$data, msa$outcome)
# formula ia a symbolic description of the model to be fit. See randomForestSRC
if(class(msa) == "msaWrapperTte"){
formula <- as.formula(Surv(time, event) ~ .)
names(data) <- c(names(msa$data), names(msa$outcome))
}else{
formula <- as.formula(outcome ~ .)
names(data) <- c(names(msa$data), "outcome")
}
# data will contain the outcome
current_data <- data
# x will have just the covariates
p = dim(data)[2]
#outcome <- data[, c(p-1,p)]
#current_x <- data[, -c(p-1,p)]
outcome <- msa$outcome
current_x <- msa$data
train_c_index <- vector()
OOB_c_index <- vector()
valid_c_index <- vector()
train_ci_sd <- vector()
OOB_ci_sd <- vector()
valid_ci_sd <- vector()
active_covars <- vector()
p = dim(current_x)[2]
active_covar_names <- list()
active_covar_scores <- list()
n_repeat = 1
# repeat until 1 covar left
repeat {
active_covar_names[[n_repeat]] <- names(current_x)
current_p = dim(current_x)[2]
print(paste0(current_p, "/", p, " covariates"))
#print(names(current_x))
# vector/matrix to keep scores
importance <- matrix(nrow = current_p, ncol = iterations)
train_ci_i <- vector(length = iterations)
OOB_ci_i <- vector(length = iterations)
valid_ci_i <- vector(length = iterations)
ProgressBar <- utils::txtProgressBar(min = 1, max = iterations,
initial = 1, style = 3)
for (i in 1:iterations){
utils::setTxtProgressBar(ProgressBar, i)
if(byOOB == FALSE){
# split data randomly for cross validation
n = dim(current_data)[1]
ind <- sample(c(TRUE, FALSE), n, replace=TRUE, prob=c(0.5, 0.5))
train_x <- current_data[ind,]
train_data <- current_data[ind,]
valid_x <- current_x[!ind,]
valid_data <- current_data[!ind,]
} else {
# Not doing cross validation
train_x <- current_x
train_data <- current_data
valid_x <- NA
valid_data <- NA
}
# train RF
rf <- randomForestSRC::rfsrc(formula,
data = train_data,
na.action = "na.impute",
importance = TRUE,
proximity = TRUE)
if(is.data.frame(rf$importance)) importance[,i] <- rf$importance[,1]
else importance[,i] <- rf$importance
# The "predicted" values are mortality = risk score
# use c.index as a performance score
# raw training prediction
train_ci_i[i] = randomForestSRC::get.cindex(rf$yvar[,1], rf$yvar[,2], -rf$predicted)
# OOB prediction
OOB_ci_i[i] = randomForestSRC::get.cindex(rf$yvar[,1], rf$yvar[,2], -rf$predicted.oob)
if(byOOB == FALSE) {
# Validation prediction instead
pred <- predict(rf, newdata = valid_data, na.action = "na.impute", outcome = "test")
valid_ci_i[i] = randomForestSRC::get.cindex(pred$yvar[,1], pred$yvar[,2], -pred$predicted.oob)
}
}
close(ProgressBar)
# get stats
train_c_index <- c(train_c_index, mean(train_ci_i))
OOB_c_index <- c(OOB_c_index, mean(OOB_ci_i))
valid_c_index <- c(valid_c_index, mean(valid_ci_i))
train_ci_sd <- c(train_ci_sd, sd(train_ci_i))
OOB_ci_sd <- c(OOB_ci_sd, sd(OOB_ci_i))
valid_ci_sd <- c(valid_ci_sd, sd(valid_ci_i))
active_covars <- c(active_covars, current_p)
# Choose a covar to remove
score <- importance
scores <- apply(score, 1, sum)
active_covar_scores[[n_repeat]] <- scores
scores_names <- names(current_x)[order(scores)]
# reduce the covariates by one!!!!!!!!!!!!!
current_x <- current_x[,scores_names[2:current_p]]
current_data <- cbind(current_x, outcome)
n_repeat <- n_repeat+1
# if x has been reduced to a vector, we are on the last covariate
if(is.vector(current_x)){
#print(scores_names[2])  # the one left at the end
active_covar_names[[n_repeat]] <- scores_names[2]
active_covar_scores[[n_repeat]] <- NA
break
}
}
# choose optimal model
if(byOOB == TRUE){
# Choose max of OOB performance
max_i <- which.max(OOB_c_index)
}else{
# Choose max of validation performance
max_i <- which.max(valid_c_index)
}
optimal_p <- active_covars[max_i]
optimal_names <- active_covar_names[[max_i]]
#x <- data[, -c(p-1,p)]
x <- msa$data
optimal_x <- subset(x, select = optimal_names)
optimal_data <- cbind(optimal_x, outcome)
print(paste("Optimal p=", optimal_p))
# Do iterations to find a good rf with optimal p
best_perf = 0
best_rf = NULL
for (i in 1:iterations){
setTxtProgressBar(ProgressBar, i)
# train RF
rf <- randomForestSRC::rfsrc(formula,
data = optimal_data,
na.action = "na.impute",
importance = TRUE,
proximity = TRUE)
# OOB prediction
perf = randomForestSRC::get.cindex(rf$yvar[,1], rf$yvar[,2], -rf$predicted.oob)
if(perf > best_perf){
best_perf = perf
best_rf <- rf
}
}
performance <- data.frame(active_covars,
train_c_index, train_ci_sd,
OOB_c_index, OOB_ci_sd,
valid_c_index, valid_ci_sd)
# return this object
structure(list(iterations, byOOB,
performance,
active_covar_names,
active_covar_scores,
optimal_p, optimal_names,
best_perf,
best_rf),
.Names = c("iterations", "byOOB",
"performance",
"active_covar_names", "active_covar_scores",
"optimal_p", "Optimal_covars",
"best_c_index",
"trained_random_forest"),
class = "msaWrapperRandomSurvivalForest")
}
rf_oc <- buildRandomForest2(msa_oc, iterations = 4)
debugonce(buildRandomForest2)
rf_oc <- buildRandomForest2(msa_oc, iterations = 4)
class(rf$importance)
#' buildRandomForest.msaWrapperTte
#'
#' Build a Random Forest Classifier for time to event outcome
#' @param msa The msaWrapper object to work with.
#' @param iterations The number of randomForest calls to make for the active covars.
#' @param byOOB Use out of bag performance measure, if false use 50:50 cross validation
#' @return An object containing the trained RF and it's performance.
#' @export
#'
#buildRandomForest.msaWrapperTte <- function(msa, iterations=200, byOOB = TRUE){
buildRandomForest2 <- function(msa, iterations=200, byOOB = TRUE){
#stopifnot(msa$type == "time to event data")
# data is a Data frame containing the y-outcome (2 cols at the end) and x-variables. No label column.
data <- cbind(msa$data, msa$outcome)
# formula ia a symbolic description of the model to be fit. See randomForestSRC
if(class(msa) == "msaWrapperTte"){
formula <- as.formula(Surv(time, event) ~ .)
names(data) <- c(names(msa$data), names(msa$outcome))
}else{
formula <- as.formula(outcome ~ .)
names(data) <- c(names(msa$data), "outcome")
}
# data will contain the outcome
current_data <- data
# x will have just the covariates
p = dim(data)[2]
#outcome <- data[, c(p-1,p)]
#current_x <- data[, -c(p-1,p)]
outcome <- msa$outcome
current_x <- msa$data
train_c_index <- vector()
OOB_c_index <- vector()
valid_c_index <- vector()
train_ci_sd <- vector()
OOB_ci_sd <- vector()
valid_ci_sd <- vector()
active_covars <- vector()
p = dim(current_x)[2]
active_covar_names <- list()
active_covar_scores <- list()
n_repeat = 1
# repeat until 1 covar left
repeat {
active_covar_names[[n_repeat]] <- names(current_x)
current_p = dim(current_x)[2]
print(paste0(current_p, "/", p, " covariates"))
#print(names(current_x))
# vector/matrix to keep scores
importance <- matrix(nrow = current_p, ncol = iterations)
train_ci_i <- vector(length = iterations)
OOB_ci_i <- vector(length = iterations)
valid_ci_i <- vector(length = iterations)
ProgressBar <- utils::txtProgressBar(min = 1, max = iterations,
initial = 1, style = 3)
for (i in 1:iterations){
utils::setTxtProgressBar(ProgressBar, i)
if(byOOB == FALSE){
# split data randomly for cross validation
n = dim(current_data)[1]
ind <- sample(c(TRUE, FALSE), n, replace=TRUE, prob=c(0.5, 0.5))
train_x <- current_data[ind,]
train_data <- current_data[ind,]
valid_x <- current_x[!ind,]
valid_data <- current_data[!ind,]
} else {
# Not doing cross validation
train_x <- current_x
train_data <- current_data
valid_x <- NA
valid_data <- NA
}
# train RF
rf <- randomForestSRC::rfsrc(formula,
data = train_data,
na.action = "na.impute",
importance = TRUE,
proximity = TRUE)
if(is.matrix(rf$importance)) importance[,i] <- rf$importance[,1]
else importance[,i] <- rf$importance
# The "predicted" values are mortality = risk score
# use c.index as a performance score
# raw training prediction
train_ci_i[i] = randomForestSRC::get.cindex(rf$yvar[,1], rf$yvar[,2], -rf$predicted)
# OOB prediction
OOB_ci_i[i] = randomForestSRC::get.cindex(rf$yvar[,1], rf$yvar[,2], -rf$predicted.oob)
if(byOOB == FALSE) {
# Validation prediction instead
pred <- predict(rf, newdata = valid_data, na.action = "na.impute", outcome = "test")
valid_ci_i[i] = randomForestSRC::get.cindex(pred$yvar[,1], pred$yvar[,2], -pred$predicted.oob)
}
}
close(ProgressBar)
# get stats
train_c_index <- c(train_c_index, mean(train_ci_i))
OOB_c_index <- c(OOB_c_index, mean(OOB_ci_i))
valid_c_index <- c(valid_c_index, mean(valid_ci_i))
train_ci_sd <- c(train_ci_sd, sd(train_ci_i))
OOB_ci_sd <- c(OOB_ci_sd, sd(OOB_ci_i))
valid_ci_sd <- c(valid_ci_sd, sd(valid_ci_i))
active_covars <- c(active_covars, current_p)
# Choose a covar to remove
score <- importance
scores <- apply(score, 1, sum)
active_covar_scores[[n_repeat]] <- scores
scores_names <- names(current_x)[order(scores)]
# reduce the covariates by one!!!!!!!!!!!!!
current_x <- current_x[,scores_names[2:current_p]]
current_data <- cbind(current_x, outcome)
n_repeat <- n_repeat+1
# if x has been reduced to a vector, we are on the last covariate
if(is.vector(current_x)){
#print(scores_names[2])  # the one left at the end
active_covar_names[[n_repeat]] <- scores_names[2]
active_covar_scores[[n_repeat]] <- NA
break
}
}
# choose optimal model
if(byOOB == TRUE){
# Choose max of OOB performance
max_i <- which.max(OOB_c_index)
}else{
# Choose max of validation performance
max_i <- which.max(valid_c_index)
}
optimal_p <- active_covars[max_i]
optimal_names <- active_covar_names[[max_i]]
#x <- data[, -c(p-1,p)]
x <- msa$data
optimal_x <- subset(x, select = optimal_names)
optimal_data <- cbind(optimal_x, outcome)
print(paste("Optimal p=", optimal_p))
# Do iterations to find a good rf with optimal p
best_perf = 0
best_rf = NULL
for (i in 1:iterations){
setTxtProgressBar(ProgressBar, i)
# train RF
rf <- randomForestSRC::rfsrc(formula,
data = optimal_data,
na.action = "na.impute",
importance = TRUE,
proximity = TRUE)
# OOB prediction
perf = randomForestSRC::get.cindex(rf$yvar[,1], rf$yvar[,2], -rf$predicted.oob)
if(perf > best_perf){
best_perf = perf
best_rf <- rf
}
}
performance <- data.frame(active_covars,
train_c_index, train_ci_sd,
OOB_c_index, OOB_ci_sd,
valid_c_index, valid_ci_sd)
# return this object
structure(list(iterations, byOOB,
performance,
active_covar_names,
active_covar_scores,
optimal_p, optimal_names,
best_perf,
best_rf),
.Names = c("iterations", "byOOB",
"performance",
"active_covar_names", "active_covar_scores",
"optimal_p", "Optimal_covars",
"best_c_index",
"trained_random_forest"),
class = "msaWrapperRandomSurvivalForest")
}
rf_oc <- buildRandomForest2(msa_oc, iterations = 4)
library(msaWrapper)
debugonce(buildRandomForest)
rf_oc <- buildRandomForest(msa_oc, iterations = 4)
train_data$outcome
library(msaWrapper)
rf_oc <- buildRandomForest(msa_oc, iterations = 4)
library(msaWrapper)
rf_oc <- buildRandomForest(msa_oc, iterations = 2)
library(msaWrapper)
rf_oc <- buildRandomForest(msa_oc, iterations = 2)
library(msaWrapper)
rf_oc <- buildRandomForest(msa_oc, iterations = 2)
View(rf_oc)
View(rf_oc[["performance"]])
rf_tte <- buildRandomForest(msa_tte, iterations = 2)
View(rf_tte)
msa_oc_red <- reduceByCorrelationWithinGroups(msa_oc)
debugonce(buildRandomForest)
rf_oc <- buildRandomForest(msa_oc_red, iterations = 2)
rf$predicted
rf$predicted.oob
train_x
train_data$outcome
rf$predicted
rf$predicted[,1]
rf$predicted[,2]
class(rf$predicted)
names(rf$predicted)
colnames(rf$predicted)
colnames(rf$predicted)[max(rf$predicted)]
colnames(rf$predicted)[max.col(rf$predicted)]
View(rf)
rf$class
train_data$outcome
rf$class.oob
library(msaWrapper)
rf_oc <- buildRandomForest(msa_oc_red, iterations = 2)
View(rf_oc)
View(rf_tte)
library(msaWrapper)
rf_tte <- buildRandomForest(msa_tte, iterations = 2)
library(msaWrapper)
library(msaWrapper)
plotRandomForestPerformance(rf_oc)
plotRandomForestPerformance(rf_tte)
View(rf_tte)
library(msaWrapper)
plotRandomForestPerformance(rf_oc)
library(msaWrapper)
plotRandomForestPerformance(rf_oc)
plotRandomForestPerformance(rf_oc)
plotRandomForestPerformance(rf_tte)
library(msaWrapper)
plotRandomForestPerformance(rf_oc)
plotRandomForestPerformance(rf_tte)
library(msaWrapper)
plotRandomForestPerformance(rf_oc)
plotRandomForestPerformance(rf_tte)
library(usethis)
use_package("ini")
tempfile(fileext = '.ini')
getwd()
sink(file = "grot.ini")
cat("; This line is a comment\n")
cat("# This one too!\n")
cat("[    Hello World]\n")
cat("Foo = Bar          \n")
cat("Foo1 = Bar=345 \n")
sink()
nlevels(msa$outcome)
msa$outcome
nlevels(msa_oc$outcome)
nlevels(msa$outcome$event)
msa$outcome$event
nlevels(as.factor(msa$outcome$event))
library(msaWrapper)
use_package("stringr")
library(msaWrapper)
use_r("plotSPSignature")
use_package("strex")
help("stopifnot")
use_package("tidyr")
library(msaWrapper)
